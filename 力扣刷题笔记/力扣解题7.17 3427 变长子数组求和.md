---
文档名-title: 力扣解题7.17 3427 变长子数组求和
创建时间-create time: 2025-07-17 14:15
更新时间-modefived time: 2025-07-17 14:16 星期四
文档粗分-text: 笔记
笔记细分-text: 
笔记索引-link: '[[笔记总索引]]'
继承自-link: 
tags:
  - 笔记
模板自: -笔记-规范（2024.6.8）
---
# 课程笔记：子数组和问题

## 一、题目框架整理与关键点分析

### 1. 输入输出形式
- **输入**：一个长度为 `n` 的整数数组 `nums`。
- **输出**：一个整数，表示数组中每个下标定义的子数组中所有元素的总和。

### 2. 约束条件
- `1 <= n == nums.length <= 100`
- `1 <= nums[i] <= 1000`

### 3. 题意解析
- 对于每个下标 `i`，定义子数组 `nums[start ... i]`，其中 `start = max(0, i - nums[i])`。
- 需要计算每个子数组的和，并将所有子数组的和累加起来。

## 二、代码实现与知识点解释

### 解法一：暴力解法
```python
class Solution:
    def subarraySum(self, nums: List[int]) -> int:
        result = 0
        for i in range(len(nums)):
            start = max(0, i - nums[i])  # 确定子数组的起始位置
            sub = nums[start:i + 1]     # 获取子数组
            sst = 0
            for ss in sub:              # 计算子数组的和
                sst += ss
            result += sst
        return result
```
- **知识点**：
  - **列表切片**：`nums[start:i + 1]` 用于获取子数组。
  - **循环嵌套**：外层循环遍历每个下标，内层循环计算子数组的和。
- **优点**：逻辑简单，易于理解。
- **缺点**：时间复杂度较高，效率较低。

### 解法二：差分数组 + 前缀和（未优化）
```python
class Solution:
    def subarraySum(self, nums: List[int]) -> int:
        result = 0
        need = []
        for i in range(0, len(nums)):
            need.append(max(0, i - nums[i]))  # 记录每个子数组的起始位置
        sum1 = nums
        for i in range(1, len(nums)):
            sum1[i] += sum1[i - 1]  # 计算前缀和
        total = 0
        for i in range(len(nums)):
            total += sum1[i]
            if need[i] != 0:
                total -= sum1[need[i] - 1]  # 减去不需要的部分
        return total
```
- **知识点**：
  - **前缀和**：`sum1[i] += sum1[i - 1]`，用于快速计算子数组的和。
  - **差分数组**：`need` 数组记录每个子数组的起始位置。
- **优点**：利用前缀和减少了重复计算。
- **缺点**：代码结构不够简洁，存在冗余计算。

### 解法三：优化解法二
```python
class Solution:
    def subarraySum(self, nums: List[int]) -> int:
        result = 0
        need = [0]
        total = nums[0]
        for i in range(1, len(nums)):
            need.append(max(0, i - nums[i]))
            nums[i] += nums[i - 1]  # 计算前缀和
            total += nums[i]
            if need[i] != 0:
                total -= nums[need[i] - 1]  # 减去不需要的部分
        return total
```
- **知识点**：
  - **前缀和优化**：直接在原数组上进行前缀和计算，减少额外空间。
  - **差分数组优化**：通过一次遍历完成所有计算，减少循环次数。
- **优点**：时间复杂度和空间复杂度都得到了优化。
- **缺点**：代码逻辑稍显复杂，需要仔细理解。

## 三、时间复杂度与空间复杂度分析

### 解法一
- **时间复杂度**：`O(n^2)`。外层循环 `n` 次，内层循环最坏情况下也接近 `n` 次。
- **空间复杂度**：`O(1)`。除了输入数组外，只使用了常数级别的额外空间。

### 解法二
- **时间复杂度**：`O(n)`。虽然有三个循环，但每个循环都是线性时间复杂度。
- **空间复杂度**：`O(n)`。额外使用了 `need` 数组和 `sum1` 数组。

### 解法三
- **时间复杂度**：`O(n)`。只用了一个循环，每次操作都是常数时间。
- **空间复杂度**：`O(1)`。在原数组上进行操作，只使用了常数级别的额外空间。

## 四、优化方向与提示

1. **进一步优化空间复杂度**：
   - 当前解法三已经将空间复杂度优化到 `O(1)`，但可以尝试减少临时变量的使用，例如直接在原数组上操作，避免使用 `need` 数组。

2. **减少重复计算**：
   - 在计算子数组和时，可以尝试利用已计算的前缀和，避免重复计算子数组的和。

3. **代码结构优化**：
   - 尝试将逻辑拆分成更小的函数，使代码更清晰易懂。

## 五、解题亮点
- **解法三**通过一次循环完成了所有计算，同时利用前缀和减少了重复计算，时间复杂度和空间复杂度都得到了优化。

希望这份笔记能帮助你更好地理解和掌握这道题的解题思路和优化方法！