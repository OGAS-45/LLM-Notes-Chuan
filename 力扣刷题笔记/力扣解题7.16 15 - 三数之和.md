---
文档名-title: 力扣解题7.16 15 - 三数之和
创建时间-create time: 2025-07-16 12:47
更新时间-modefived time: 2025-07-16 12:47 星期三
文档粗分-text: 笔记
笔记细分-text: 
笔记索引-link: '[[笔记总索引]]'
继承自-link: 
tags:
  - 笔记
模板自: -笔记-规范（2024.6.8）
---


# LeetCode 15. 3Sum 课程笔记  
（附个人代码演进记录 & 优化指南）

---

## 一、题目框架 & 关键点速查

| 维度 | 描述 |
|---|---|
| **输入** | 整数数组 `nums`，长度 `3 ≤ n ≤ 3000`，元素范围 `[-1e5, 1e5]` |
| **输出** | 所有 **不重复** 的三元组 `[a,b,c]`，满足 `a + b + c = 0` |
| **约束** | 顺序无关，但三元组本身不能重复（值层面） |
| **暗示** | `n=3k` 时 `O(n³)` 必 TLE，需要 `O(n²)` 级算法 |

---

## 二、个人代码演进轨迹

| 版本 | 核心思路 | 关键代码片段（精简） | 学到的知识点 & 可延伸 |
|---|---|---|---|
| **解法一** | 暴力二维矩阵 + 线性查表 | 先存 `matrix[i][j] = -(nums[i]+nums[j])`，再 `in nums` 找第三数 | • 二维数组初始化模板<br>• 下三角遍历 `j < i`<br>• **时间 O(n³)** → TLE |
| **解法二** | 哈希去重 | `target in set(nums)`，`result_set.add(tuple(sorted(...)))` | • `set` vs `list` 的 `O(1)` 查询<br>• `tuple` 可哈希，用于去重<br>• 仍是 `O(n²)`，但去掉 `list in` 后勉强 AC |
| **解法三** | 排序 + 双指针 | `for mid in range(n):` + `while left < right:` | • 排序后指针移动方向与和值关系<br>• 边界 `left < right`<br>• 仍用 `set` 去重，额外空间 |
| **解法四** | **优化双指针** | 固定 `i`，`left = i+1, right = n-1`，原地跳过重复 | • 排序后相邻去重<br>• **O(n²) / O(1)**（不含输出）<br>• 无需 `set`，直接 `result.append()` |

---

## 三、复杂度推导

| 阶段 | 时间 | 空间 |
|---|---|---|
| 排序 | `O(n log n)` | `O(log n)` ~ `O(n)` |
| 双指针主循环 | `Σ(n-i-1) = O(n²)` | `O(1)` |
| **总和** | `O(n²)` | `O(1)`（不计输出） |

---

## 四、进一步优化方向（不泄露完整代码）

1. **剪枝**  
   - 当 `nums[i] > 0` 时直接 `break`  
   - `nums[i] + nums[i+1] + nums[i+2] > 0` 亦可 `break`

2. **重复值压缩**  
   - 用 `Counter` 统计出现次数，把查找转成“两数之和”变体，常数更小

3. **二分查找**  
   - 固定前两个数后，第三个数用二分；复杂度仍为 `O(n² log n)`，但 cache 友好

4. **kSum 模板化**  
   - 抽象为“固定 `k-2` 个数 + 双指针”，可解 4Sum、3Sum Closest 等

5. **位运算/哈希压缩**  
   - 元素范围极小时用 `bitset` 或布尔数组，把 `in` 查询降到位运算

---

## 五、本次解题亮点（来自个人笔记）

| 亮点 | 说明 |
|---|---|
| **降维打击** | 亲手体验 `O(n³) → O(n²)` 的演进 |
| **去重技巧** | 排序后“相邻跳过”比 `set` 省内存 |
| **边界意识** | 多次踩坑：`left < right`、越界检查 |
| **调试可视化** | `print(i, left, right, total)` 快速定位死循环 |

---

## 六、一句话总结

> **排序 + 双指针 + 相邻去重** 是 3Sum 的黄金公式；掌握它，kSum 皆通。
