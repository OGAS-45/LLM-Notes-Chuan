---
文档名-title: 力扣解题206 - 反转链表
创建时间-create time: 2025-06-26 17:01
更新时间-modefived time: 2025-06-26 17:01 星期四
文档粗分-text: 笔记
笔记细分-text: 
笔记索引-link: '[[笔记总索引]]'
继承自-link: 
tags:
  - 笔记
模板自: -笔记-规范（2024.6.8）
---


# 《链表反转问题课程笔记》

## 一、题目框架整理与关键点分析

### （一）输入输出形式
- **输入**：单链表的头节点 `head`，链表中的每个节点包含一个整数值 `val` 和指向下一个节点的指针 `next`。
- **输出**：反转后的链表头节点。

### （二）约束条件
- 链表中节点的数目范围是 `[0, 5000]`，这意味着链表可能为空，也可能有最多 5000 个节点。
- 节点的值范围是 `-5000 <= Node.val <= 5000`，即链表中的值可以是任意整数。

### （三）题意解析
- **核心目标**：将链表中的节点顺序完全反转。例如，原链表为 `1 -> 2 -> 3 -> 4 -> 5`，反转后应为 `5 -> 4 -> 3 -> 2 -> 1`。
- **特殊情况处理**：
  - 如果链表为空（`head = None`），直接返回 `None`。
  - 如果链表只有一个节点，反转后仍然是该节点本身。

## 二、代码粘贴与知识点解释

以下是你的代码，我将对其进行详细解释：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def redd2(self, n1: Optional[ListNode], n2: Optional[ListNode]) -> Optional[ListNode]:
        # 迭代脱出：递是不断往里面的，所以终止条件在尾巴
        if n2.next is None:
            n2.next = n1
            return n2
        else:
            # 这一段写得很好
            print(n2.val)
            t = n2.next
            n2.next = n1
            return self.redd2(n2, t)
            # 有一个很重要的，需要层层上传出去

    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return None
        else:
            return self.redd2(None, head)
```

### （一）知识点介绍
1. **递归反转链表**
   - **核心思想**：通过递归调用，逐步将链表节点的指向反转。
   - **递归终止条件**：当 `n2.next` 为 `None` 时，说明已经到达链表的末尾，此时将 `n2.next` 指向 `n1`，并返回 `n2` 作为新的头节点。
   - **递归过程**：
     - 每次递归调用时，将当前节点 `n2` 的 `next` 指针指向 `n1`。
     - 通过 `t = n2.next` 保存下一个节点，然后递归调用 `self.redd2(n2, t)`，逐步向链表的末尾推进。
   - **关键点**：递归过程中需要正确处理节点的指针反转，并确保递归返回时能够正确连接节点。

2. **链表的遍历与操作**
   - 通过 `n2.next` 访问链表的下一个节点，并通过 `n2.next = n1` 改变节点的指向。
   - 使用递归的方式可以避免手动维护指针的复杂性，但需要注意递归的终止条件和返回值。

### （二）延伸知识点
- **迭代反转链表**：除了递归方法外，还可以通过迭代的方式反转链表。迭代方法通过循环逐步改变节点的指向，通常需要维护三个指针（前一个节点、当前节点和下一个节点）。
- **链表的遍历与操作**：链表的遍历是通过逐个访问节点的 `next` 指针完成的。在反转链表时，需要注意节点指针的正确更新，避免丢失链表的连接。

## 三、代码复杂度分析

### （一）时间复杂度
- **递归反转链表的时间复杂度**：
  - 每个节点只被访问一次，每次递归调用处理一个节点。
  - 因此，时间复杂度为 **O(n)**，其中 n 是链表的长度。

### （二）空间复杂度
- **递归反转链表的空间复杂度**：
  - 递归调用会占用栈空间，每次递归调用都会在栈中保存当前的调用状态。
  - 在最坏情况下（链表长度为 n），递归调用的深度为 n，因此空间复杂度为 **O(n)**。

### （三）复杂度推导过程
- **时间复杂度推导**：
  - 假设链表长度为 n，递归调用从头节点开始，逐个处理每个节点。
  - 每个节点的处理时间是常数级别的（O(1)），因此总的时间复杂度为 O(n)。
- **空间复杂度推导**：
  - 递归调用的深度为链表的长度 n，每次递归调用都会占用栈空间。
  - 因此，空间复杂度为 O(n)。

## 四、优化方向与提示

### （一）优化方向
1. **迭代方法优化**
   - 当前代码使用递归方法，虽然逻辑清晰，但空间复杂度较高（O(n)）。可以尝试使用迭代方法，将空间复杂度降低到 O(1)。
   - **思路**：通过循环逐步改变节点的指向，维护三个指针（前一个节点、当前节点和下一个节点），避免递归调用的栈空间占用。

2. **代码可读性优化**
   - 当前代码中有一些冗余的打印语句（如 `print(n2.val)`），可以移除以提高代码的效率和可读性。
   - 可以添加注释，解释每一步的操作，使代码更易于理解。

### （二）优化提示
- **迭代方法实现**：
  - 初始化三个指针：`prev = None`、`curr = head` 和 `next_node = None`。
  - 在循环中，逐步更新指针：
    - 保存当前节点的下一个节点：`next_node = curr.next`。
    - 将当前节点的 `next` 指针指向 `prev`：`curr.next = prev`。
    - 移动指针：`prev = curr`，`curr = next_node`。
  - 当 `curr` 为 `None` 时，循环结束，`prev` 指向新的头节点。

- **递归方法优化**：
  - 如果仍然使用递归方法，可以尝试减少递归调用中的冗余操作，例如避免不必要的打印语句。
  - 确保递归终止条件和返回值的正确性，避免因递归错误导致的效率问题。

---

希望这份笔记能帮助你更好地理解和掌握链表反转问题的解题思路和优化方法。如果有任何疑问，欢迎随时讨论！