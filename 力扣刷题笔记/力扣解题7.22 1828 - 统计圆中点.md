---
文档名-title: 力扣解题7.22 1828 - 统计圆中点
创建时间-create time: 2025-07-22 14:41
更新时间-modefived time: 2025-07-22 14:41 星期二
文档粗分-text: 笔记
笔记细分-text: 
笔记索引-link: '[[笔记总索引]]'
继承自-link: 
tags:
  - 笔记
模板自: -笔记-规范（2024.6.8）
---

# 课程笔记：二维平面点与圆的关系判断问题

## 一、题目分析

### 题目框架整理
- **输入形式**：
  - `points`: 二维数组，每个元素是一个包含两个整数的子数组，表示点的坐标 `[xi, yi]`
  - `queries`: 二维数组，每个元素是一个包含三个整数的子数组，表示圆的信息 `[xj, yj, rj]`
- **输出形式**：
  - 一维数组 `answer`，其中 `answer[j]` 表示第 `j` 个查询圆内的点的数量
- **约束条件**：
  - 点的坐标和圆心坐标范围：`0 <= xi, yi, xj, yj <= 500`
  - 半径范围：`1 <= rj <= 500`
  - 点和查询的数量：`1 <= points.length, queries.length <= 500`

### 关键点分析
- **核心问题**：判断一个点是否在圆内（包括边界）
- **几何条件**：点 `(x, y)` 在圆 `(cx, cy, r)` 内的条件是：
$$
  (x - cx)^2 + (y - cy)^2 <= r^2
$$
  这是基于圆的标准方程 `(x - cx)^2 + (y - cy)^2 = r^2`，当点到圆心的距离小于等于半径时，点在圆内或边界上。

### 题意解析
- 对于每个查询圆，需要遍历所有点，判断每个点是否满足上述几何条件
- 需要高效地进行双重遍历（查询和点）并统计符合条件的点数

## 二、代码讲解

### 解法一：直接计算（运行速度 561ms）

```python
class Solution:
    def countPoints(self, points: List[List[int]], queries: List[List[int]]) -> List[int]:
        result = [0] * len(queries)
        # 从圆开始遍历
        for i, circle in enumerate(queries):
            rr = circle[2] ** 2
            for j, point in enumerate(points):
                if rr >= (point[0] - circle[0]) ** 2 + (point[1] - circle[1]) ** 2:
                    result[i] += 1
        return result
```

**代码逻辑**：
1. 初始化结果数组 `result`，长度与查询数量相同
2. 遍历每个查询圆：
   - 计算半径平方 `rr = r^2`（避免重复计算）
   - 遍历所有点，判断是否满足 `(x - cx)^2 + (y - cy)^2 <= rr`
   - 满足条件则结果计数加1

**知识点**：
- 二维平面点与圆的关系判断
- 双重循环结构的应用
- 平方运算的优化（提前计算半径平方）

**不足**：
- 使用 `**` 运算符计算平方，效率相对较低
- 内层循环中重复计算了 `(point[0] - circle[0])` 和 `(point[1] - circle[1])`

### 解法二：优化后的计算（运行速度 339ms）

```python
class Solution:
    def countPoints(self, points: List[List[int]], queries: List[List[int]]) -> List[int]:
        result = [0] * len(queries)
        for i, circle in enumerate(queries):
            cx, cy, r = circle
            rr = r * r  # r * r 比 r ** 2 更快
            for point in points:
                x, y = point
                dx = x - cx
                dy = y - cy
                if dx * dx + dy * dy <= rr:
                    result[i] += 1
        return result
```

**优化点**：
1. 使用 `r * r` 代替 `r ** 2`，乘法运算比幂运算更快
2. 显式计算 `dx` 和 `dy`，避免重复计算坐标差
3. 使用更直观的变量命名（`cx, cy, r` 和 `x, y`），提高代码可读性

## 三、时间与空间复杂度分析

### 时间复杂度
- **解法一和解法二**：
  - 外层循环：`m` 次（`m` 为查询数量）
  - 内层循环：`n` 次（`n` 为点的数量）
  - 每次内层循环操作：常数时间（判断和计数）
  - 总时间复杂度：`O(m * n)`
  - 推导：对于每个查询，都需要遍历所有点进行判断，总操作次数为 `m * n` 次常数时间操作。

### 空间复杂度
- **解法一和解法二**：
  - 结果数组：`O(m)`（存储每个查询的结果）
  - 其他变量：常数空间
  - 总空间复杂度：`O(m)`
  - 推导：除了输入数据外，主要的额外空间是结果数组，其大小与查询数量相同。

## 四、优化方向提示

1. **数学优化**：
   - 可以考虑将点预处理到某种空间索引结构（如网格划分），减少需要判断的点的数量
   - 提示：根据圆的最大可能半径，确定哪些点可能在圆附近

2. **算法优化**：
   - 探索基于排序或 hashing 的方法，减少双重循环的次数
   - 提示：可以对点按坐标进行排序，然后对每个查询进行二分查找范围

3. **代码层面优化**：
   - 进一步减少重复计算（如预计算所有点的坐标差）
   - 提示：可以预先计算所有点相对于原点的坐标，但这可能需要权衡空间和时间的利弊

## 五、解题亮点总结

1. **直接应用几何知识**：通过圆的标准方程 `(x - cx)^2 + (y - cy)^2 <= r^2`，直接判断点与圆的关系，逻辑清晰且易于实现。

2. **双重循环的高效实现**：虽然时间复杂度为 `O(m * n)`，但通过优化平方运算和减少重复计算，显著提高了实际运行效率（从 561ms 优化到 339ms）。

3. **代码可读性提升**：解法二通过变量命名优化和中间变量引入，提高了代码的可读性和维护性，体现了良好的编程习惯。

4. **对边界条件的正确处理**：包括点在圆边界上的情况，完全符合题目要求。

通过这道题，我们学习了如何将几何问题转化为程序实现，以及如何通过简单的数学优化和代码结构调整来提高算法效率。这种双重循环结构在许多需要两两比较的场景中非常常见，掌握其优化方法对解决类似问题有很大帮助。
