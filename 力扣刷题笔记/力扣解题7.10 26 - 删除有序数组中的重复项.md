---
文档名-title: 力扣解题26 - 删除有序数组中的重复项
创建时间-create time: 2025-07-10 15:56
更新时间-modefived time: 2025-07-10 15:56 星期四
文档粗分-text: 笔记
笔记细分-text: 
笔记索引-link: '[[笔记总索引]]'
继承自-link: 
tags:
  - 笔记
模板自: -笔记-规范（2024.6.8）
---


# 课程笔记：删除排序数组中的重复项

## 1. 题目框架整理与关键点分析

### 题目要求
- **输入**：非严格递增排列的整数数组 `nums`
- **输出**：返回唯一元素的数量 `k`，并将数组前 `k` 个元素修改为唯一元素
- **约束条件**：
  - 数组长度：1 ≤ nums.length ≤ 3×10⁴
  - 元素范围：-10⁴ ≤ nums[i] ≤ 10⁴
  - 必须原地修改数组（空间复杂度 O(1)）

### 关键点解析
1. **非严格递增**：允许相邻元素相等
2. **原地修改**：不能使用额外数组
3. **保持相对顺序**：不能打乱原有顺序
4. **判题标准**：只检查前 `k` 个元素，后面元素可忽略

## 2. 代码分析与知识点

### 方法一：逐个删除重复元素
```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if nums:
            t = 0.1  # 初始化一个不可能出现在数组中的值
            num = 0
            total = 0
            while num < len(nums):
                # 不能直接if digits[num]因为这样的话当digits[num]为0的时候也不行
                if nums[num] == t:
                    # 使用remove这个题库函数会让我的运行时间大大减缓
                    nums.remove(t)
                else:
                    t = nums[num]
                    num += 1
                    total += 1
            return total
```

**知识点与思考**：
- 使用 `0.1` 作为哨兵值，避免与数组中的整数冲突
- 注意到 `if nums[num]` 的问题：当元素为0时会被误判为False
- `list.remove()` 的时间复杂度为 O(n)，导致整体性能下降

### 方法二：双指针法（更优解）
```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if nums:
            t = 0
            dd = 0
            while t < len(nums) and dd < len(nums):
                # 不能直接if digits[num]因为这样的话当digits[num]为0的时候也不行
                if nums[dd] == nums[t]:
                    dd += 1
                else:
                    nums[t + 1] = nums[dd]
                    t += 1
            return t + 1
```

**知识点与思考**：
- **双指针技巧**：使用两个指针 `t`（慢指针）和 `dd`（快指针）
- **原地修改**：通过覆盖而非删除元素来优化性能
- 变量命名可以更清晰（如 `slow` 和 `fast`）

## 3. 复杂度分析

### 方法一
- **时间复杂度**：O(n²)
  - 最坏情况下需要遍历整个数组（O(n)）
  - 每次 `remove()` 操作需要 O(n) 时间移动元素
  - 总体：O(n) × O(n) = O(n²)
  
- **空间复杂度**：O(1)
  - 只使用了常数个额外变量

### 方法二
- **时间复杂度**：O(n)
  - 每个元素最多被访问两次（快指针和慢指针各一次）
  
- **空间复杂度**：O(1)
  - 只使用了两个指针变量

## 4. 优化方向与提示

### 进一步优化建议：
1. **变量命名优化**：
   - 使用更有意义的变量名，如 `slow`, `fast` 或 `write`, `read`

2. **边界条件处理**：
   - 考虑空数组的特殊情况
   - 思考是否需要显式处理 `nums` 为 `None` 的情况

3. **代码简洁性**：
   - 探索更简洁的双指针实现方式
   - 考虑使用 Python 的特性简化代码

4. **算法思路**：
   - 思考是否有其他原地修改数组的方法
   - 考虑如何处理更复杂的去重场景（如允许保留最多k个重复元素）

### 提示：
- 双指针法是处理数组问题的常用技巧
- 原地修改通常比删除操作更高效
- 注意处理数组边界和特殊情况

## 5. 解题亮点

1. **发现问题能力**：
   - 注意到 `if nums[num]` 对0值的误判问题
   - 意识到 `remove()` 操作的性能问题

2. **算法优化思维**：
   - 从 O(n²) 的解法优化到 O(n) 的双指针解法
   - 理解原地修改的重要性

3. **调试技巧**：
   - 使用哨兵值（如0.1）避免特殊情况
   - 通过注释记录思考过程

4. **学习态度**：
   - 主动比较两种方法的性能差异
   - 关注代码的可读性和维护性

---

**总结**：这道题是经典的数组去重问题，通过双指针技巧可以在 O(n) 时间内原地完成。关键在于理解快慢指针的作用：快指针探索新元素，慢指针记录唯一元素的位置。这种思维模式可以应用到许多类似的数组处理问题中。