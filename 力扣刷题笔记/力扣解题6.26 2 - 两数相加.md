---
文档名-title: 力扣解题2 - 两数相加
创建时间-create time: 2025-06-26 11:56
更新时间-modefived time: 2025-06-26 11:57 星期四
文档粗分-text: 笔记
笔记细分-text: 
笔记索引-link: '[[笔记总索引]]'
继承自-link: 
tags:
  - 笔记
模板自: -笔记-规范（2024.6.8）
---

#### 一、题目框架整理与关键点分析

**题目描述：**  
给定两个非空链表，每个链表的节点存储一位数字，数字以逆序方式存储（即链表头为最低位）。要求将这两个链表表示的数字相加，并返回一个新的链表，表示它们的和。

**输入输出形式：**  
- **输入**：两个链表 `l1` 和 `l2`，节点值为单个数字（0-9）。
- **输出**：一个链表，表示两个数字相加的结果。

**约束条件：**  
1. 每个链表的节点数在 `[1, 100]` 范围内。
2. 每个节点的值在 `[0, 9]` 范围内。
3. 输入的链表不会以 `0` 开头（除非链表只有一个节点，且值为 `0`）。

**题意解析：**  
- 链表的逆序存储方式意味着链表头节点对应最低位数字。
- 相加过程类似于手工加法，从最低位开始逐位相加，处理进位。
- 需要考虑链表长度不一致的情况，以及最后可能产生的进位。

#### 二、代码解析

**代码结构：**  
代码中定义了一个 `Solution` 类，其中包含两个方法：
1. `addNode`：用于创建新节点并处理进位。
2. `addTwoNumbers`：主方法，负责遍历链表并调用 `addNode` 完成相加。

**代码解释：**  
```python
class Solution:
    def addNode(self, n1: int, n2: int, add_flag: int, curr: Optional[ListNode]) -> tuple[int, Optional[ListNode]]:
        qq = (n1 + n2 + add_flag) % 10  # 当前位的和（取模10）
        add_flag = (n1 + n2 + add_flag) // 10  # 进位标志
        currq = ListNode(qq)  # 创建新节点
        curr.next = currq  # 将新节点链接到链表
        curr = curr.next  # 移动指针
        return add_flag, curr
```
- **知识点：**  
  - **链表操作**：通过 `curr.next` 和 `curr = curr.next` 实现链表的构建。
  - **进位处理**：利用 `%` 和 `//` 操作符分别获取当前位的值和进位标志。
  - **元组返回值**：函数返回一个元组，包含进位标志和当前节点指针。

```python
def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
    curr = ListNode(0)  # 创建一个哑节点作为链表头
    head = curr
    add_flag = 0  # 初始化进位标志
    while l1 and l2:  # 同时遍历两个链表
        add_flag, curr = self.addNode(l1.val, l2.val, add_flag, curr)
        l1 = l1.next
        l2 = l2.next
    while l1:  # 处理剩余的 l1
        add_flag, curr = self.addNode(l1.val, 0, add_flag, curr)
        l1 = l1.next
    while l2:  # 处理剩余的 l2
        add_flag, curr = self.addNode(0, l2.val, add_flag, curr)
        l2 = l2.next
    if add_flag:  # 处理最后的进位
        add_flag, curr = self.addNode(0, 0, add_flag, curr)
    return head.next  # 返回结果链表
```
- **知识点：**  
  - **循环控制**：通过 `while` 循环分别处理两个链表的公共部分和剩余部分。
  - **哑节点**：使用哑节点简化链表操作，避免头节点的特殊情况。
  - **链表拼接**：通过 `curr.next` 将新节点逐个链接到结果链表。

#### 三、时间复杂度与空间复杂度分析

**时间复杂度：**  
- **分析过程：**  
  - 主循环分别遍历两个链表，最多遍历 `O(max(M, N))` 次，其中 `M` 和 `N` 分别是两个链表的长度。
  - 每次调用 `addNode` 的时间复杂度为 `O(1)`。
  - 最后处理进位的操作也是 `O(1)`。
- **结论：**  
  时间复杂度为 **`O(max(M, N))`**，其中 `M` 和 `N` 分别是两个链表的长度。

**空间复杂度：**  
- **分析过程：**  
  - 创建了一个新的链表来存储结果，其长度最多为 `max(M, N) + 1`（考虑最后的进位）。
  - 除了输入链表外，额外空间主要用于新链表的节点。
- **结论：**  
  空间复杂度为 **`O(max(M, N))`**。

#### 四、优化方向与提示

1. **减少函数调用：**  
   当前代码中，`addNode` 函数被多次调用，每次调用都会进行类似的计算。可以将这部分逻辑直接嵌入主循环中，减少函数调用的开销。

2. **链表长度预处理：**  
   在开始相加之前，可以先计算两个链表的长度，然后根据长度差异优化遍历逻辑，避免多余的循环。

3. **尾部进位优化：**  
   如果在主循环结束后发现进位标志为 `1`，可以直接在链表尾部追加一个值为 `1` 的节点，而不是再次调用 `addNode`。

4. **代码简化：**  
   当前代码中存在一些冗余逻辑，可以通过合并条件判断和简化操作来减少代码量。例如，处理剩余链表的两个 `while` 循环可以合并为一个。

5. **内存优化：**  
   如果允许修改输入链表，可以尝试直接在原链表上操作，减少新节点的创建，从而降低空间复杂度。

通过以上优化方向的探索，可以进一步提升算法的效率和可读性。