---
文档名-title: 力扣解题61 - 旋转链表
创建时间-create time: 2025-06-26 15:50
更新时间-modefived time: 2025-06-26 15:50 星期四
文档粗分-text: 笔记
笔记细分-text: 
笔记索引-link: '[[笔记总索引]]'
继承自-link: 
tags:
  - 笔记
模板自: -笔记-规范（2024.6.8）
---

# 课程笔记：链表旋转问题

## 一、题目框架整理与关键点分析

### 1. 输入输出形式
- **输入**：
  - `head`：链表的头节点，表示链表的起始位置。链表由若干个节点组成，每个节点包含一个值（`val`）和一个指向下一个节点的指针（`next`）。
  - `k`：一个整数，表示链表中每个节点需要向右移动的位数。
- **输出**：
  - 返回一个新的链表头节点，表示旋转后的链表。

### 2. 约束条件
- 链表中节点的数目在范围 `[0, 500]` 内。
- 节点的值范围为 `-100 <= Node.val <= 100`。
- 移动的位数 `0 <= k <= 2 * 10^9`。

### 3. 题意解析
- **核心问题**：将链表中的每个节点向右移动 `k` 个位置。如果链表长度为 `n`，则实际上需要移动的位数是 `k % n`（因为移动 `n` 位相当于没有移动）。
- **难点**：
  - 需要处理链表的尾部和头部的连接问题。
  - 需要避免形成环形链表导致程序陷入死循环。
  - 当链表长度为 `1` 或 `k` 为 `0` 时，链表不需要旋转。

## 二、代码解释与知识点介绍

### 代码整体逻辑
1. **边界条件处理**：
   - 如果链表为空或只有一个节点，或者 `k` 为 `0`，则直接返回原链表。
2. **建立环形链表**：
   - 遍历链表，找到链表的尾节点，并将其指向头节点，形成一个环形链表。
   - 同时统计链表的总长度 `total`。
3. **找到旋转点**：
   - 通过计算 `total - (k % total) - 1`，找到旋转后的尾节点。
   - 将旋转后的尾节点的 `next` 指针设置为 `None`，并更新头节点。
4. **返回结果**：
   - 返回新的头节点。

### 知识点介绍与代码亮点
1. **环形链表的构建与断开**：
   - 通过将尾节点的 `next` 指针指向头节点，形成环形链表，便于找到旋转后的尾节点。
   - 在完成旋转后，必须断开环形链表，避免死循环。
2. **链表长度的计算**：
   - 在构建环形链表的过程中，通过遍历链表统计其长度，为后续计算旋转点提供依据。
3. **模运算的优化**：
   - 使用 `k % total` 来处理 `k` 值可能大于链表长度的情况，避免不必要的重复移动。

### 代码片段解释
```python
tt = curr.next
total = 1
while tt:
    if tt.next is None:
        break
    tt = tt.next
    total += 1
tt.next = curr.next
```
- 这段代码的作用是找到链表的尾节点，并将其与头节点连接，形成环形链表。
- 同时统计链表的总长度 `total`，为后续计算旋转点提供依据。

```python
for num in range(0, total - (k % total) - 1):
    t = t.next
curr.next = t.next
t.next = None
```
- 这段代码通过循环找到旋转后的尾节点 `t`。
- 将 `t.next` 设置为 `None`，并更新头节点为 `curr.next`，完成链表的旋转。

## 三、时间复杂度与空间复杂度分析

### 时间复杂度
1. **构建环形链表**：
   - 遍历链表一次，时间复杂度为 \(O(n)\)，其中 \(n\) 是链表的长度。
2. **找到旋转点**：
   - 再次遍历链表，时间复杂度为 \(O(n)\)。
3. **总时间复杂度**：
   - 整个算法的时间复杂度为 \(O(n)\)，因为两次遍历链表的操作是线性的。

### 空间复杂度
- 除了输入的链表外，只使用了一个额外的虚拟头节点 `curr` 和一些指针变量。
- 因此，空间复杂度为 \(O(1)\)。

## 四、优化方向与提示

### 优化方向
1. **减少遍历次数**：
   - 当前代码中，需要两次遍历链表（一次构建环形链表，一次找到旋转点）。可以尝试在第一次遍历时完成所有操作，减少一次遍历。
2. **处理特殊情况**：
   - 当链表长度为 `1` 或 `k` 为 `0` 时，直接返回原链表，避免不必要的操作。
3. **避免环形链表**：
   - 虽然环形链表可以简化逻辑，但也可以通过直接计算旋转点的方式避免构建环形链表，从而减少代码复杂度和潜在的错误。

### 提示
- **优化遍历逻辑**：在第一次遍历时，同时计算链表长度和找到尾节点，然后直接计算旋转点，避免第二次遍历。
- **注意边界条件**：在处理链表问题时，始终要注意边界条件，如链表为空、只有一个节点等。
- **避免环形链表的陷阱**：虽然环形链表可以简化逻辑，但如果不小心断开，可能会导致程序陷入死循环。